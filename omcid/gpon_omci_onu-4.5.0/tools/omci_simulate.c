/******************************************************************************

                              Copyright (c) 2011
                            Lantiq Deutschland GmbH
                     Am Campeon 3; 85579 Neubiberg, Germany

  For licensing information, see the file 'LICENSE' in the root folder of
  this software module.

******************************************************************************/
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define OMCI_CMD_PIPE		"/var/pipe/omci_0_cmd"
#define OMCI_ACK_PIPE		"/var/pipe/omci_0_ack"

#define OMCI_FIFO_FULL		(-15)

#define OMCI_SIMULATE_COPYRIGHT "(c) Copyright 2012, Lantiq Deutschland GmbH"
#define OMCI_SIMULATE_VERSION	"0.0.3"
#define OMCI_SIMULATE_WHAT_STR "@(#)OMCI Simulate, version " \
				OMCI_SIMULATE_VERSION " " \
				OMCI_SIMULATE_COPYRIGHT

#define OMCI_MAX_ACTION_TIMEOUT	(10000)
#define OMCI_MAX_BUF_LEN	(256)

#define CMD_RET_ERRORCODE		"errorcode"

#define CMD_MESSAGE_RECV		"raw_message_recv"

#define CMD_ACTION_TIMEOUT_GET		"action_timeout_get"
#define CMD_RET_ACTION_TIMEOUT_GET	"action_timeout"

#define CMD_ACTION_TIMEOUT_SET		"action_timeout_set"

#define CMD_MSG_NUM_GET			"msg_num_get"
#define CMD_RET_MSG_NUM_GET		"num"

const char omci_simulate_whatversion[] = OMCI_SIMULATE_WHAT_STR;

static char *find_nth_sep(char *p, char sep, int n)
{
	int i = 0;

	while (*p) {
		if (*p == sep)
			i++;

		if (i == n)
			return p;

		p++;
	}

	return NULL;
}

/** return -1 on error */
static int pipe_write(const char *p)
{
	FILE *pipe_cmd;

	pipe_cmd = fopen(OMCI_CMD_PIPE, "w");
	if (!pipe_cmd) {
		fprintf(stderr, "Can't open OMCI pipe '%s'\n", OMCI_CMD_PIPE);
		return -1;
	}

	fprintf(pipe_cmd, "%s\n", p);

	fclose(pipe_cmd);

	return 0;
}

/** return -1 on error */
static int pipe_read(char *p, size_t max_len)
{
	FILE *pipe_ack;
	size_t n;

	pipe_ack = fopen(OMCI_ACK_PIPE, "r");
	if (!pipe_ack) {
		fprintf(stderr, "Can't open OMCI pipe '%s'\n", OMCI_ACK_PIPE);
		return -1;
	}

	n = fread(p, 1, max_len, pipe_ack);
	fclose(pipe_ack);

	p[n] = '\0';

	return 0;
}

static void do_simulate(FILE *input)
{
	static const int req_sep_cnt = 7;
	static const int req_space_cnt = 39;
	static const int retry_max = 100;
	char buf[1024], res[1024];
	char *begin, *end;
	int ret, errorcode, retry;

	while (fgets(buf, sizeof(buf), input)) {
		if (buf[0] != 'r' || buf[1] != 'x')
			continue;

		begin = find_nth_sep(buf, '|', req_sep_cnt);
		if (!begin || *begin == '\0')
			continue;

		begin++;

		end = find_nth_sep(begin, ' ', req_space_cnt);
		if (!end)
			continue;

		*end = '\0';

		printf("%s\n", begin);
		retry = 0;
		do {
			sprintf(res, CMD_MESSAGE_RECV " %s", begin);
#ifdef DEBUG
			printf(CMD_MESSAGE_RECV " %s\n", begin);
#endif
			ret = pipe_write(res);
			if (ret)
				return;

			ret = pipe_read(res, sizeof(res));
			if (ret)
				return;

			sscanf(res, CMD_RET_ERRORCODE "=%d\n", &errorcode);

			retry++;
		} while (errorcode == OMCI_FIFO_FULL && retry < retry_max);

		printf("%s", res);
	}
}

static void usage(const char *appname)
{
	printf("Usage: %s [FILE]\n", appname);
	printf("\n");
	printf("Forward RX OMCI messages from the log generated by ONU "
	       "daemon \n"
	       "into running instance of OMCI ONU daemon.\n");
}

static int args_parse(int argc, char *argv[], char **filename)
{

	if (argc < 2) {
		usage(argv[0]);
		return -1;
	}

	if (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0) {
		usage(argv[0]);
		return -1;
	}

	if (strcmp(argv[1], "-v") == 0 || strcmp(argv[1], "--version") == 0) {
		printf(OMCI_SIMULATE_WHAT_STR "\n");
		return -1;
	}

	*filename = argv[1];

	return 0;
}

static unsigned int get_action_timeout(void)
{
	char buf[OMCI_MAX_BUF_LEN];
	int ret, errorcode, action_timeout;

	if (pipe_write(CMD_ACTION_TIMEOUT_GET))
		return -1;

	if (pipe_read(buf, sizeof(buf)))
		return -1;

	ret = sscanf(buf,
		     CMD_RET_ERRORCODE "=%d "
		     CMD_RET_ACTION_TIMEOUT_GET "=%d", &errorcode,
		     &action_timeout);
	if (ret != 2)
		return -1;

	if (errorcode < 0)
		return -1;

	return action_timeout;
}

static int set_action_timeout(unsigned int action_timeout)
{
	char buf[OMCI_MAX_BUF_LEN];
	int ret, errorcode;

	ret = sprintf(buf, CMD_ACTION_TIMEOUT_SET " %u", action_timeout);
	if (!ret)
		return -1;

	if (pipe_write(buf))
		return -1;

	if (pipe_read(buf, sizeof(buf)))
		return -1;

	ret = sscanf(buf, CMD_RET_ERRORCODE "=%d", &errorcode);
	if (ret != 1)
		return -1;

	if (errorcode < 0)
		return -1;

	return 0;
}

static int get_msg_num(void)
{
	char buf[OMCI_MAX_BUF_LEN];
	int ret, errorcode, num;

	if (pipe_write(CMD_MSG_NUM_GET))
		return -1;

	if (pipe_read(buf, sizeof(buf)))
		return -1;

	ret = sscanf(buf,
		     CMD_RET_ERRORCODE "=%d "
		     CMD_RET_MSG_NUM_GET "=%d", &errorcode, &num);
	if (ret != 2)
		return -1;

	if (errorcode < 0)
		return -1;

	return num;
}

static int wait_for_handling(void)
{
	int num, prev_num = 0;

	/* wait until number of messages in the queue goes to 0 (all messages
	 * are handled);
	 * afterwards we can set action timeout to the original value */

	printf("Wait until all messages are handled");
	fflush(stdout);
	while ((num = get_msg_num()) != 0) {
		if (num < 0) {
			printf("\n");
			fprintf(stderr, "Can't get number of messages in the "
				"queue; don't set action timeout to the "
				"original value\n");
			return -1;
		}

		if (prev_num && num > prev_num) {
			printf("\n");
			fprintf(stderr, "Number of messages "
				"increased while waiting for all "
				"messages to be handled; "
				"don't set action timeout to the "
				"original value\n");
			return -1;
		}

		prev_num = num;

		sleep(1);

		printf(".");
		fflush(stdout);
	}
	printf("\n");

	return 0;
}

int main(int argc, char *argv[])
{
	char *filename = NULL;
	FILE *input = NULL;
	int ret;
	unsigned int action_timeout;

	ret = args_parse(argc, argv, &filename);
	if (ret)
		return ret;

	input = fopen(filename, "r");
	if (!input) {
		fprintf(stderr, "Can't open input file '%s'\n", filename);
		return -1;
	}

	ret = get_action_timeout();
	if (ret < 0) {
		fprintf(stderr, "Can't get action timeout (%d)\n", ret);
		goto exit;
	}

	action_timeout = ret;
	ret = set_action_timeout(OMCI_MAX_ACTION_TIMEOUT);
	if (ret < 0) {
		fprintf(stderr, "Can't set action timeout (%d)\n", ret);
		goto exit;
	}

	do_simulate(input);

	ret = wait_for_handling();
	if (ret < 0)
		goto exit;

	ret = set_action_timeout(action_timeout);
	if (ret < 0) {
		fprintf(stderr, "Can't restore action timeout (%d)\n", ret);
		goto exit;
	}

exit:
	fclose(input);

	return ret;
}
